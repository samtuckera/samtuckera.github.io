<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Romantic Moments ‚Äî Optimized</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  
  <script>
(() => {
  const PASSWORD = 'samshow1010';
  const LS_KEY = 'romantic_last_unlock';
  const HIDE_CLASS = 'romantic-hidden-overlay';
  const HOUR_MS = 60 * 60 * 1000;

  const overlay = document.createElement('div');
  overlay.id = 'romantic-auth-overlay';
  overlay.style.position = 'fixed';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.zIndex = '999999';
  overlay.style.background = 'linear-gradient(180deg, rgba(0,0,0,0.95), rgba(0,0,0,0.9))';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.backdropFilter = 'blur(4px)';
  overlay.style.boxSizing = 'border-box';
  overlay.style.padding = '20px';

  const card = document.createElement('div');
  card.style.maxWidth = '420px';
  card.style.width = '100%';
  card.style.background = '#0b0b0b';
  card.style.borderRadius = '12px';
  card.style.padding = '28px';
  card.style.boxShadow = '0 10px 30px rgba(0,0,0,0.6)';
  card.style.color = '#fff';
  card.style.fontFamily = 'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial';
  card.style.textAlign = 'center';

  const title = document.createElement('div');
  title.textContent = 'Enter password to view';
  title.style.fontSize = '18px';
  title.style.marginBottom = '12px';
  title.style.color = '#ff6b6b';

  const sub = document.createElement('div');
  sub.textContent = 'Password required once per hour';
  sub.style.fontSize = '12px';
  sub.style.color = '#bdbdbd';
  sub.style.marginBottom = '18px';

  const input = document.createElement('input');
  input.type = 'password';
  input.placeholder = 'Password';
  input.autocomplete = 'current-password';
  input.style.width = '100%';
  input.style.padding = '12px 14px';
  input.style.fontSize = '15px';
  input.style.borderRadius = '8px';
  input.style.border = '1px solid rgba(255,255,255,0.06)';
  input.style.background = '#0f0f0f';
  input.style.color = '#fff';
  input.style.boxSizing = 'border-box';
  input.style.outline = 'none';
  input.style.marginBottom = '12px';

  const btn = document.createElement('button');
  btn.textContent = 'Go';
  btn.style.display = 'inline-block';
  btn.style.width = '100%';
  btn.style.padding = '12px';
  btn.style.fontSize = '15px';
  btn.style.borderRadius = '8px';
  btn.style.border = 'none';
  btn.style.cursor = 'pointer';
  btn.style.background = 'linear-gradient(90deg,#ff3b30,#ff2d55)';
  btn.style.color = '#fff';
  btn.style.fontWeight = '600';

  const msg = document.createElement('div');
  msg.style.fontSize = '13px';
  msg.style.marginTop = '10px';
  msg.style.minHeight = '18px';
  msg.style.color = '#ff9b9b';

  const info = document.createElement('div');
  info.style.fontSize = '11px';
  info.style.color = '#9aa4b2';
  info.style.marginTop = '10px';

  card.appendChild(title);
  card.appendChild(sub);
  card.appendChild(input);
  card.appendChild(btn);
  card.appendChild(msg);
  card.appendChild(info);
  overlay.appendChild(card);
  document.documentElement.appendChild(overlay);

  function now() { return Date.now(); }
  function setLastUnlock(ts) { try { localStorage.setItem(LS_KEY, String(ts)); } catch(e) {} }
  function getLastUnlock() { try { const v = localStorage.getItem(LS_KEY); return v ? Number(v) : 0; } catch(e) { return 0; } }
  function clearMessage() { msg.textContent = ''; }
  function showMessage(text, short=false) { msg.textContent = text; if(!short) setTimeout(clearMessage, 4000); }

  function evaluateOverlay() {
    const last = getLastUnlock();
    if (last && (now() - last) < HOUR_MS) {
      hideOverlay();
    } else {
      showOverlay();
    }
    updateInfo();
  }

  function updateInfo() {
    const last = getLastUnlock();
    if (!last) {
      info.textContent = 'Not unlocked yet';
      return;
    }
    const diff = now() - last;
    if (diff >= HOUR_MS) {
      info.textContent = 'Unlock expired ‚Äî password required';
    } else {
      const msLeft = HOUR_MS - diff;
      const minutes = Math.ceil(msLeft / 60000);
      info.textContent = `Unlocked ‚Äî ${minutes} minute(s) until next password`;
    }
  }

  function showOverlay() {
    overlay.style.display = 'flex';
    input.value = '';
    input.focus();
    document.documentElement.style.overflow = 'hidden';
  }

  function hideOverlay() {
    overlay.style.display = 'none';
    document.documentElement.style.overflow = '';
  }

  function attemptUnlock() {
    const val = input.value || '';
    if (!val) {
      showMessage('Type the password', true);
      input.focus();
      return;
    }
    if (val === PASSWORD) {
      setLastUnlock(now());
      updateInfo();
      hideOverlay();
      showMessage('', true);
    } else {
      showMessage('Wrong password');
      input.value = '';
      input.focus();
    }
  }

  btn.addEventListener('click', attemptUnlock);
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') attemptUnlock();
  });

  setInterval(() => {
    const last = getLastUnlock();
    if (!last) return;
    if ((now() - last) >= HOUR_MS) {
      if (overlay.style.display === 'none' || overlay.style.display === '') {
        showOverlay();
        updateInfo();
      } else {
        updateInfo();
      }
    } else {
      updateInfo();
    }
  }, 10 * 1000);

  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) input.focus();
  });

  try { evaluateOverlay(); } catch (e) { showOverlay(); console.error(e); }

  window.__romanticAuth = {
    forceLock: () => { localStorage.removeItem(LS_KEY); showOverlay(); },
    forceUnlock: () => { setLastUnlock(now()); hideOverlay(); }
  };
})();
  </script>

  <style>
    :root { --bg: #000; --card: #0b0b0b; --muted: #9aa4b2; --primary: #ff3b30; }
    html,body { height:100%; margin:0; background:#3b3b3b; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
    .wrap { padding:20px; max-width:1100px; margin:0 auto; }
    h2 { text-align:center; color:var(--primary); letter-spacing:1px; margin-bottom:18px; }
    #request-btn { display:none; background:linear-gradient(45deg,#ff3b30,#ff2d55); color:#fff; border:none; padding:12px 20px; border-radius:20px; font-weight:600; cursor:pointer; margin: 0 auto 16px; display:block; max-width:260px; }

    .gallery { display:grid; grid-template-columns:repeat(2,1fr); gap:10px; }
    
    .photo-card { 
        position:relative; 
        border-radius:12px; 
        overflow:hidden; 
        background:#111; 
        aspect-ratio:3/4; 
        box-shadow:0 2px 8px rgba(0,0,0,0.5); 
        display:flex; 
        align-items:center; 
        justify-content:center; 
        cursor:pointer; 
        user-select:none;
        transition: transform 0.2s;
    }
    .photo-card:active { transform: scale(0.98); }

    /* Thumbnail Image Style */
    .photo-thumb {
        width: 100%;
        height: 100%;
        object-fit: cover;
        position: absolute;
        inset: 0;
        z-index: 1;
        opacity: 0; /* Hidden until loaded */
        transition: opacity 0.3s ease;
    }
    .photo-thumb.loaded { opacity: 1; }

    .photo-card .placeholder { 
        width:100%; height:100%; 
        display:flex; align-items:center; justify-content:center; 
        gap:8px; flex-direction:column; 
        color:#aaa; font-size:13px; padding:12px; text-align:center;
        z-index: 0;
    }
    
    .photo-date { 
        position:absolute; bottom:0; left:0; right:0; 
        background:linear-gradient(to top, rgba(0,0,0,0.9), transparent); 
        color:#fff; font-size:10px; padding:12px 6px 6px; 
        text-align:center; pointer-events:none; 
        z-index: 3; text-shadow: 0 1px 2px #000;
    }
    
    /* Number Tag */
    .photo-number {
        position: absolute;
        top: 6px;
        left: 6px;
        background: rgba(0,0,0,0.6);
        backdrop-filter: blur(4px);
        color: #fff;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 4px;
        z-index: 3;
        font-weight: 700;
        font-family: monospace;
    }

    /* Viewed Tick */
    .viewed-tick {
        position: absolute;
        top: 6px;
        right: 6px;
        background: #2ecc71;
        color: #000;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        z-index: 3;
        box-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }

    .loader { text-align:center; color:var(--muted); margin-top:10px; display:none; }

    /* Modal */
    .modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:999999; background:rgba(0,0,0,0.95); }
    .modal.open { display:flex; }
    .modal-content { position:relative; width:clamp(300px,90vw,1000px); max-height:100%;overflow:hidden; background:#000; display:flex; align-items:center; justify-content:center; }
    .modal video { max-width:100%; max-height:100%; display:block;outline: none; }
    .modal .close { position:absolute; top:10px; right:10px; background:rgba(0,0,0,0.5); color:#fff; border:none; font-size:20px; width:40px; height:40px; border-radius:999px; cursor:pointer; display:flex; align-items:center; justify-content:center; z-index: 10; }
    .modal .toggle {
      position:absolute; top:10px; right:60px;
      background:rgba(0,0,0,0.55); color:#fff; border:none; font-size:22px; width:40px; height:40px;
      border-radius:999px; cursor:pointer; display:flex; align-items:center; justify-content:center; user-select:none; z-index: 10;
    }
    .modal .hint { position:absolute; bottom:8px; left:10px; right:10px; text-align:center; color:#ddd; font-size:13px; pointer-events:none; text-shadow:0 1px 3px #000; z-index: 10; }

    .back-link { display:block; text-align:center; margin-top:18px; color:#007AFF; text-decoration:none; font-size:14px; }
    
    /* Skeleton Loader for Modal */
    .skeleton-overlay {
        position: absolute; inset: 0;
        background: #1a1a1a;
        display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        z-index: 5;
    }
    .skeleton-shimmer {
        width: 100%; height: 100%;
        background: linear-gradient(90deg, #1a1a1a 25%, #2a2a2a 50%, #1a1a1a 75%);
        background-size: 200% 100%;
        animation: loading 1.5s infinite;
    }
    @keyframes loading { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    
    /* Spinner inside skeleton */
    .spinner { width:36px; height:36px; border-radius:50%; border:4px solid rgba(255,255,255,0.08); border-top-color:#ff6b6b; animation:spin 1s linear infinite; }
    @keyframes spin { to { transform:rotate(360deg) } }

    .end-note { text-align:center; color:var(--muted); padding:12px 0; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>‚ù§Ô∏è Romantic Moments</h2>
    <button id="request-btn">üì∏ Request Instant Selfie</button>
    <div id="gallery" class="gallery" aria-live="polite"></div>
    <div id="main-loader" class="loader">Syncing memories... <span id="loader-spinner" style="display:inline-block;vertical-align:middle;margin-left:8px;"></span></div>
    <div id="end-note" class="end-note" style="display:none;">No more items.</div>
    <a href="index.html" class="back-link">‚Üê Back to Chat</a>
  </div>

  <div id="modal" class="modal" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true">
      <button id="modal-close" class="close" title="Close">‚úï</button>
      <button id="modal-toggle" class="toggle" title="Play / Pause">‚ñ∂Ô∏è</button>
      
      <div id="modal-skeleton" class="skeleton-overlay" style="display:none;">
        <div class="skeleton-shimmer" style="position:absolute;inset:0;"></div>
        <div style="position:relative;z-index:2;text-align:center;">
            <div class="spinner" style="margin:0 auto 10px;"></div>
            <div style="font-size:12px;color:#888;">Decrypting Secure Memory...</div>
        </div>
      </div>

    </div>
  </div>

  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
  import {
    getFirestore, collection, query, orderBy, limit, onSnapshot, getDocs, startAfter, serverTimestamp, addDoc
  } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";
  import { getAuth, setPersistence, browserLocalPersistence, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";

  // ============ INDEXED DB HELPER ============
  const DB_NAME = "RomanticGalleryDB";
  const DB_VERSION = 1;
  const STORE_NAME = "metadata"; // Stores: { id: "docId", number: 100, viewed: bool, thumbnail: "base64" }
  const CONFIG_STORE = "config"; // Stores: { id: "max_number", value: 100 }

  let idb = null;

  const initDB = () => {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME, { keyPath: "id" });
            }
            if (!db.objectStoreNames.contains(CONFIG_STORE)) {
                db.createObjectStore(CONFIG_STORE, { keyPath: "id" });
            }
        };
        request.onsuccess = (e) => { idb = e.target.result; resolve(idb); };
        request.onerror = (e) => reject(e);
    });
  };

  // Get Metadata for a specific doc ID
  const getMeta = async (docId) => {
    if (!idb) await initDB();
    return new Promise((resolve) => {
        const tx = idb.transaction(STORE_NAME, "readonly");
        const store = tx.objectStore(STORE_NAME);
        const req = store.get(docId);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => resolve(null);
    });
  };

  // Save Metadata (merging)
  const saveMeta = async (docId, data) => {
    if (!idb) await initDB();
    const current = await getMeta(docId) || { id: docId };
    const merged = { ...current, ...data };
    return new Promise((resolve) => {
        const tx = idb.transaction(STORE_NAME, "readwrite");
        tx.objectStore(STORE_NAME).put(merged);
        tx.oncomplete = () => resolve(merged);
    });
  };

  // Assign a unique number starting at 100 if not exists
  const assignNumberIfNeeded = async (docId) => {
    if (!idb) await initDB();
    // Check if exists
    const existing = await getMeta(docId);
    if (existing && existing.number) return existing.number;

    return new Promise((resolve) => {
        const tx = idb.transaction([STORE_NAME, CONFIG_STORE], "readwrite");
        const configStore = tx.objectStore(CONFIG_STORE);
        
        // Get max number
        const req = configStore.get("max_number");
        req.onsuccess = () => {
            let nextNum = 100;
            if (req.result) {
                nextNum = req.result.value + 1;
            }
            
            // Update config
            configStore.put({ id: "max_number", value: nextNum });
            
            // Update metadata store logic requires separate handling inside transaction scope ideally, 
            // but for brevity in this helper structure:
            const metaStore = tx.objectStore(STORE_NAME);
            const metaReq = metaStore.get(docId);
            metaReq.onsuccess = () => {
                const record = metaReq.result || { id: docId };
                record.number = nextNum;
                metaStore.put(record);
            }
            resolve(nextNum);
        };
    });
  };

  // ============ FIREBASE CONFIG ============
  const firebaseConfig = {
    apiKey: "AIzaSyCuIDz0QP1Gpb6_40fz7xBY9xihPBuv3OE",
    authDomain: "sas-chat-61205.firebaseapp.com",
    projectId: "sas-chat-61205",
    storageBucket: "sas-chat-61205.firebasestorage.app",
    messagingSenderId: "775011152776",
    appId: "1:775011152776:web:e2bec0fe7e1fea99c5003d"
  };

  const ALLOWED_UIDS = [
    '3Och1e5kXyQfFsHtdGP6zosWMmr1',
    '9bX4Pye70VNymSt0CIZYBg7U47I3'
  ];

  const PAGE_SIZE = 20;

  // ============ INIT ============
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  const gallery = document.getElementById('gallery');
  const btn = document.getElementById('request-btn');
  const loader = document.getElementById('main-loader');
  const loaderSpinner = document.getElementById('loader-spinner');
  const endNote = document.getElementById('end-note');

  const modal = document.getElementById('modal');
  const modalContent = modal.querySelector('.modal-content');
  const modalClose = document.getElementById('modal-close');
  const modalToggle = document.getElementById('modal-toggle');
  const modalSkeleton = document.getElementById('modal-skeleton');

  const vaultKey = localStorage.getItem("secure_vault");
  const currentUserLabel = localStorage.getItem("secure_user");

  // state
  let lastDoc = null;
  let loadingMore = false;
  let reachedEnd = false;
  let liveUnsubscribe = null;
  let activeBlobUrl = null;
  let activeVideoEl = null;
  
  // Navigation State
  let currentOpenDocId = null; // To track where we are for next/prev

  // Helpers
  function showMainLoader(show=true) { loader.style.display = show ? 'block' : 'none'; if (show) loaderSpinner.innerHTML = '<div class="spinner"></div>'; else loaderSpinner.innerHTML=''; }
  function decryptWithKey(cipherText) {
    try { return CryptoJS.AES.decrypt(cipherText, vaultKey).toString(CryptoJS.enc.Utf8); } catch (e) { return null; }
  }
  async function dataURItoBlob(dataURI) {
    const res = await fetch(dataURI);
    return await res.blob();
  }

  if (currentUserLabel === 'sam10') {
    btn.style.display = 'block';
    btn.addEventListener('click', requestSelfie);
  }

  setPersistence(auth, browserLocalPersistence).catch(e => console.warn('Persistence err', e));

  // Modal Events
  modalClose.addEventListener('click', closeModal);
  modal.addEventListener('click', (ev) => { if (ev.target === modal) closeModal(); });
  modalToggle.addEventListener('click', (ev) => {
    ev.stopPropagation();
    if (!activeVideoEl) return;
    if (activeVideoEl.paused) activeVideoEl.play().catch(()=>{});
    else activeVideoEl.pause();
  });

  // ============ NAVIGATION LOGIC ============
  
  function getCardList() {
    return Array.from(document.querySelectorAll('.photo-card'));
  }

  function navigateGallery(direction) {
    if (!currentOpenDocId || modal.style.display === 'none') return;
    
    const cards = getCardList();
    const currentIndex = cards.findIndex(c => c.id === `card-${currentOpenDocId}`);
    
    if (currentIndex === -1) return;

    let nextIndex = direction === 'next' ? currentIndex + 1 : currentIndex - 1;

    if (nextIndex >= 0 && nextIndex < cards.length) {
        // Emulate closing and opening next
        const nextCard = cards[nextIndex];
        // Extract data attached to the DOM element (we'll attach it in render)
        if (nextCard.dataset.docId) {
            // Need to fetch the docSnap associated. 
            // Since we don't want to store heavy docSnaps in DOM, we can re-fetch from cache or 
            // more simply: The render function logic had the docSnap in scope. 
            // We will trigger the click event on the next card.
            nextCard.click();
        }
    }
  }

  // Keyboard Nav
  window.addEventListener('keydown', (e) => {
    if (modal.style.display !== 'none') {
        if (e.key === 'ArrowRight') navigateGallery('next');
        if (e.key === 'ArrowLeft') navigateGallery('prev');
    }
  });

  // Swipe Nav
  let touchStartX = 0;
  window.addEventListener('touchstart', e => { touchStartX = e.changedTouches[0].screenX; });
  window.addEventListener('touchend', e => {
    if (modal.style.display === 'none') return;
    const touchEndX = e.changedTouches[0].screenX;
    if (touchStartX - touchEndX > 50) navigateGallery('next'); // Swipe Left -> Next
    if (touchEndX - touchStartX > 50) navigateGallery('prev'); // Swipe Right -> Prev
  });


  onAuthStateChanged(auth, async (user) => {
    if (!user || !ALLOWED_UIDS.includes(user.uid) || !vaultKey) {
      window.location.href = 'index.html'; return;
    }
    await initDB(); // Initialize IDB
    await loadFirstPage();
    initScrollListener();
  });

  async function loadFirstPage() {
    showMainLoader(true);
    if (liveUnsubscribe) { liveUnsubscribe(); liveUnsubscribe = null; }
    
    const q = query(collection(db, "cuteselfies"), orderBy("t", "desc"), limit(PAGE_SIZE));
    
    liveUnsubscribe = onSnapshot(q, (snapshot) => {
      showMainLoader(false);
      if (snapshot.empty) {
        gallery.innerHTML = `<div style="grid-column:span 2;text-align:center;color:#444">No cute moments yet...</div>`;
        reachedEnd = true;
        endNote.style.display = 'block';
        return;
      }

      gallery.innerHTML = '';
      snapshot.docs.forEach((docSnap) => {
        const idx = snapshot.docs.indexOf(docSnap);
        renderPlaceholderCard(docSnap, idx);
      });

      lastDoc = snapshot.docs[snapshot.docs.length - 1];
      reachedEnd = snapshot.docs.length < PAGE_SIZE;
      endNote.style.display = reachedEnd ? 'block' : 'none';
    });
  }

  async function loadNextPage() {
    if (loadingMore || reachedEnd || !lastDoc) return;
    loadingMore = true;
    showMainLoader(true);
    try {
      const qMore = query(collection(db, "cuteselfies"), orderBy("t", "desc"), startAfter(lastDoc), limit(PAGE_SIZE));
      const snap = await getDocs(qMore);
      if (snap.empty) {
        reachedEnd = true;
        endNote.style.display = 'block';
      } else {
        snap.docs.forEach((d, i) => {
          renderPlaceholderCard(d, gallery.children.length + i);
        });
        lastDoc = snap.docs[snap.docs.length - 1];
        reachedEnd = snap.docs.length < PAGE_SIZE;
        endNote.style.display = reachedEnd ? 'block' : 'none';
      }
    } catch (e) { console.error(e); } finally { loadingMore = false; showMainLoader(false); }
  }

  async function renderPlaceholderCard(docSnap, index) {
    const id = docSnap.id;
    const data = docSnap.data();
    const dateText = data.t ? data.t.toDate().toLocaleDateString() : 'Recently';
    
    // 1. Get Local Metadata (Number, Viewed, Thumb)
    let num = await assignNumberIfNeeded(id);
    let meta = await getMeta(id);
    let thumbBase64 = meta ? meta.thumbnail : null;
    let isViewed = meta ? meta.viewed : false;

    const card = document.createElement('div');
    card.className = 'photo-card';
    card.id = `card-${id}`;
    card.dataset.docId = id; // For navigation lookup

    // Number Tag
    const numTag = document.createElement('div');
    numTag.className = 'photo-number';
    numTag.textContent = `#${num}`;
    card.appendChild(numTag);

    // Viewed Tick
    if (isViewed) {
        const tick = document.createElement('div');
        tick.className = 'viewed-tick';
        tick.innerHTML = '‚úì';
        card.appendChild(tick);
    }

    // Content
    const placeholder = document.createElement('div');
    placeholder.className = 'placeholder';
    
    // Thumb image if exists
    if (thumbBase64) {
        const img = document.createElement('img');
        img.src = thumbBase64;
        img.className = 'photo-thumb';
        img.onload = () => img.classList.add('loaded');
        card.appendChild(img);
    }

    placeholder.innerHTML = `<div style="font-size:28px;">üé¨</div>`;
    card.appendChild(placeholder);

    const dateEl = document.createElement('div');
    dateEl.className = 'photo-date';
    dateEl.textContent = dateText;
    card.appendChild(dateEl);

    card.addEventListener('click', (e) => {
      card.style.pointerEvents = 'none';
      openItemModal(docSnap).finally(() => {
        card.style.pointerEvents = '';
        // Refresh tick mark if it was just viewed
        if (!card.querySelector('.viewed-tick')) {
            const tick = document.createElement('div');
            tick.className = 'viewed-tick';
            tick.innerHTML = '‚úì';
            card.appendChild(tick);
        }
      });
    });

    const children = gallery.children;
    if (index >= children.length) gallery.appendChild(card); else gallery.insertBefore(card, children[index]);
  }

  // ============ GENERATE THUMBNAIL ============
  function generateThumbnail(videoEl, docId) {
    // We need to create a canvas, draw the frame, and save to IDB
    try {
        const canvas = document.createElement('canvas');
        canvas.width = videoEl.videoWidth / 2; // Scale down slightly for performance/storage
        canvas.height = videoEl.videoHeight / 2;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);
        
        const dataUrl = canvas.toDataURL('image/jpeg', 0.7);
        saveMeta(docId, { thumbnail: dataUrl });
        
        // Update UI instantly if possible
        const card = document.getElementById(`card-${docId}`);
        if (card && !card.querySelector('.photo-thumb')) {
            const img = document.createElement('img');
            img.src = dataUrl;
            img.className = 'photo-thumb loaded';
            card.appendChild(img); // Append ensures it sits over placeholder but under text
        }
    } catch(e) {
        console.warn("Thumb gen failed", e);
    }
  }

  // ============ MODAL LOAD ============
  async function openItemModal(docSnap) {
    currentOpenDocId = docSnap.id;
    
    // Show Skeleton
    modal.classList.add('open');
    modal.setAttribute('aria-hidden', 'false');
    modalSkeleton.style.display = 'flex';
    modalToggle.style.display = 'none'; // Hide controls during load

    try {
      const data = docSnap.data();
      const fetchUrl = decryptWithKey(data.d);
      if (!fetchUrl) throw new Error('Decrypt URL failed');

      const resp = await fetch(fetchUrl);
      if (!resp.ok) throw new Error('Fetch failed');
      const encryptedText = await resp.text();
      const dataUri = decryptWithKey(encryptedText);
      if (!dataUri) throw new Error('Decrypt content failed');

      const blob = await dataURItoBlob(dataUri);
      const blobUrl = URL.createObjectURL(blob);
      
      if (activeBlobUrl) { try { URL.revokeObjectURL(activeBlobUrl); } catch(e){} }
      activeBlobUrl = blobUrl;

      const vid = document.createElement('video');
      vid.controls = false;
      vid.playsInline = true;
      vid.src = blobUrl;
      vid.style.maxWidth = '100%';
      vid.style.maxHeight = '100%';
      vid.preload = 'auto';
      
      // Default Speed 0.5x
      vid.playbackRate = 0.5;

      // remove prev
      const existing = modalContent.querySelector('video, img, .err-msg');
      if (existing) existing.remove();
      
      modalContent.appendChild(vid);
      activeVideoEl = vid;

      // Handle Loaded Metadata
      vid.addEventListener('loadedmetadata', () => {
        // Set speed again to be safe
        vid.playbackRate = 0.5;
        
        // Hide Skeleton
        modalSkeleton.style.display = 'none';
        modalToggle.style.display = 'flex';
        modalToggle.textContent = '‚è∏Ô∏è';
        
        vid.play().catch(()=>{});

        // Mark as Viewed
        saveMeta(docSnap.id, { viewed: true });

        // Generate Thumbnail if not exists
        // We wait a bit to ensure frame is rendered or seek to middle
        setTimeout(() => {
            if (vid.duration && vid.duration > 0) {
                // Need to seek to middle to get a good frame? 
                // Note: Seeking might cause buffering. 
                // Simplest approach: Just grab current frame after 1 second of play
                // OR: Create a separate hidden video element to seek to middle (cleaner but heavier)
                // Let's just grab the frame at 1s or current.
                 generateThumbnail(vid, docSnap.id);
            }
        }, 1500);
      });

      vid.addEventListener('play', () => { modalToggle.textContent = '‚è∏Ô∏è'; });
      vid.addEventListener('pause', () => { modalToggle.textContent = '‚ñ∂Ô∏è'; });
      vid.addEventListener('click', () => { if (vid.paused) vid.play(); else vid.pause(); });
      vid.addEventListener('keydown', (ev) => {
        if (ev.code === 'Space') { ev.preventDefault(); if (vid.paused) vid.play(); else vid.pause(); }
      });
      
      // Focus for keys
      setTimeout(()=>vid.focus(), 100);

    } catch (err) {
      console.error(err);
      modalSkeleton.style.display = 'none';
      const errMsg = document.createElement('div');
      errMsg.className = 'err-msg';
      errMsg.style.color = '#f88';
      errMsg.textContent = 'Failed to load memory.';
      const existing = modalContent.querySelector('.err-msg');
      if (!existing) modalContent.appendChild(errMsg);
    }
  }

  function closeModal() {
    modal.classList.remove('open');
    modal.setAttribute('aria-hidden', 'true');
    currentOpenDocId = null;
    
    if (activeVideoEl) {
      try { activeVideoEl.pause(); } catch(e) {}
      activeVideoEl.remove();
      activeVideoEl = null;
    }
    if (activeBlobUrl) {
      try { URL.revokeObjectURL(activeBlobUrl); } catch(e) {}
      activeBlobUrl = null;
    }
    modalToggle.textContent = '‚ñ∂Ô∏è';
    const errMsg = modalContent.querySelector('.err-msg');
    if (errMsg) errMsg.remove();
  }

  function initScrollListener() {
    window.addEventListener('scroll', throttle(() => {
      if (loadingMore || reachedEnd) return;
      const scrolled = window.scrollY + window.innerHeight;
      const height = document.documentElement.scrollHeight;
      if (scrolled + 650 >= height) loadNextPage();
    }, 250));
  }

  function throttle(fn, wait) {
    let t = 0;
    return (...args) => {
      const now = Date.now();
      if (now - t > wait) { t = now; fn(...args); }
    };
  }

  async function requestSelfie() {
    btn.innerText = "Requesting...";
    btn.disabled = true;
    try {
      await addDoc(collection(db, "quickselfierequest"), {
        requester: currentUserLabel || 'unknown',
        t: serverTimestamp()
      });
      alert("Request Sent! üì∏");
    } catch (e) { alert('Request failed'); } finally {
      btn.innerText = "üì∏ Request Instant Selfie";
      btn.disabled = false;
    }
  }

  window.addEventListener('beforeunload', () => {
    if (activeBlobUrl) try { URL.revokeObjectURL(activeBlobUrl); } catch(e) {}
  });
  </script>
</body>
</html>
