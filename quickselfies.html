<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Romantic Moments ‚Äî Optimized</title>

  <!-- CryptoJS (you already used this) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script>
(() => {
  const PASSWORD = 'samshow1010';
  const LS_KEY = 'romantic_last_unlock';
  const HIDE_CLASS = 'romantic-hidden-overlay';
  const HOUR_MS = 60 * 60 * 1000;

  // Create overlay
  const overlay = document.createElement('div');
  overlay.id = 'romantic-auth-overlay';
  overlay.style.position = 'fixed';
  overlay.style.top = '0';
  overlay.style.left = '0';
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  overlay.style.zIndex = '999999';
  overlay.style.background = 'linear-gradient(180deg, rgba(0,0,0,0.95), rgba(0,0,0,0.9))';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.backdropFilter = 'blur(4px)';
  overlay.style.boxSizing = 'border-box';
  overlay.style.padding = '20px';

  // Inner card
  const card = document.createElement('div');
  card.style.maxWidth = '420px';
  card.style.width = '100%';
  card.style.background = '#0b0b0b';
  card.style.borderRadius = '12px';
  card.style.padding = '28px';
  card.style.boxShadow = '0 10px 30px rgba(0,0,0,0.6)';
  card.style.color = '#fff';
  card.style.fontFamily = 'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial';
  card.style.textAlign = 'center';

  // Title
  const title = document.createElement('div');
  title.textContent = 'Enter password to view';
  title.style.fontSize = '18px';
  title.style.marginBottom = '12px';
  title.style.color = '#ff6b6b';

  // Subtext
  const sub = document.createElement('div');
  sub.textContent = 'Password required once per hour';
  sub.style.fontSize = '12px';
  sub.style.color = '#bdbdbd';
  sub.style.marginBottom = '18px';

  // Input
  const input = document.createElement('input');
  input.type = 'password';
  input.placeholder = 'Password';
  input.autocomplete = 'current-password';
  input.style.width = '100%';
  input.style.padding = '12px 14px';
  input.style.fontSize = '15px';
  input.style.borderRadius = '8px';
  input.style.border = '1px solid rgba(255,255,255,0.06)';
  input.style.background = '#0f0f0f';
  input.style.color = '#fff';
  input.style.boxSizing = 'border-box';
  input.style.outline = 'none';
  input.style.marginBottom = '12px';

  // Row for button
  const btn = document.createElement('button');
  btn.textContent = 'Go';
  btn.style.display = 'inline-block';
  btn.style.width = '100%';
  btn.style.padding = '12px';
  btn.style.fontSize = '15px';
  btn.style.borderRadius = '8px';
  btn.style.border = 'none';
  btn.style.cursor = 'pointer';
  btn.style.background = 'linear-gradient(90deg,#ff3b30,#ff2d55)';
  btn.style.color = '#fff';
  btn.style.fontWeight = '600';

  // Message
  const msg = document.createElement('div');
  msg.style.fontSize = '13px';
  msg.style.marginTop = '10px';
  msg.style.minHeight = '18px';
  msg.style.color = '#ff9b9b';

  // Small "unlock time" display
  const info = document.createElement('div');
  info.style.fontSize = '11px';
  info.style.color = '#9aa4b2';
  info.style.marginTop = '10px';

  card.appendChild(title);
  card.appendChild(sub);
  card.appendChild(input);
  card.appendChild(btn);
  card.appendChild(msg);
  card.appendChild(info);
  overlay.appendChild(card);

  // Add to DOM but hidden initially (we'll decide after check)
  document.documentElement.appendChild(overlay);

  // Helpers
  function now() { return Date.now(); }
  function setLastUnlock(ts) { try { localStorage.setItem(LS_KEY, String(ts)); } catch(e) {} }
  function getLastUnlock() { try { const v = localStorage.getItem(LS_KEY); return v ? Number(v) : 0; } catch(e) { return 0; } }
  function clearMessage() { msg.textContent = ''; }
  function showMessage(text, short=false) { msg.textContent = text; if(!short) setTimeout(clearMessage, 4000); }

  // Show or hide overlay based on last unlock
  function evaluateOverlay() {
    const last = getLastUnlock();
    if (last && (now() - last) < HOUR_MS) {
      hideOverlay();
    } else {
      showOverlay();
    }
    updateInfo();
  }

  function updateInfo() {
    const last = getLastUnlock();
    if (!last) {
      info.textContent = 'Not unlocked yet';
      return;
    }
    const diff = now() - last;
    if (diff >= HOUR_MS) {
      info.textContent = 'Unlock expired ‚Äî password required';
    } else {
      const msLeft = HOUR_MS - diff;
      const minutes = Math.ceil(msLeft / 60000);
      info.textContent = `Unlocked ‚Äî ${minutes} minute(s) until next password`;
    }
  }

  function showOverlay() {
    overlay.style.display = 'flex';
    input.value = '';
    input.focus();
    // prevent scrolling behind
    document.documentElement.style.overflow = 'hidden';
  }

  function hideOverlay() {
    overlay.style.display = 'none';
    // allow scroll again
    document.documentElement.style.overflow = '';
  }

  // Attempt unlock
  function attemptUnlock() {
    const val = input.value || '';
    if (!val) {
      showMessage('Type the password', true);
      input.focus();
      return;
    }
    if (val === PASSWORD) {
      setLastUnlock(now());
      updateInfo();
      hideOverlay();
      showMessage('', true);
    } else {
      showMessage('Wrong password');
      input.value = '';
      input.focus();
    }
  }

  // Events
  btn.addEventListener('click', attemptUnlock);
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') attemptUnlock();
  });

  // Periodically re-evaluate (in case hour passes while page open)
  setInterval(() => {
    const last = getLastUnlock();
    if (!last) return;
    if ((now() - last) >= HOUR_MS) {
      // show overlay only if currently hidden
      if (overlay.style.display === 'none' || overlay.style.display === '') {
        // show again
        showOverlay();
        updateInfo();
      } else {
        updateInfo();
      }
    } else {
      // update countdown text
      updateInfo();
    }
  }, 10 * 1000); // check every 10s

  // Prevent clicks from interacting with underlying page when overlay visible
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) input.focus();
  });

  // Initial check
  try {
    evaluateOverlay();
  } catch (e) {
    // if anything goes wrong, ensure overlay is visible (fail-safe)
    showOverlay();
    console.error('Auth overlay init error', e);
  }

  // Expose a tiny API to allow hiding/showing via console if needed (optional)
  window.__romanticAuth = {
    forceLock: () => { localStorage.removeItem(LS_KEY); showOverlay(); },
    forceUnlock: () => { setLastUnlock(now()); hideOverlay(); }
  };
})();
</script>


  <style>
    :root { --bg: #000; --card: #0b0b0b; --muted: #9aa4b2; }
    html,body { height:100%; margin:0; background:var(--bg); color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
    .wrap { padding:20px; max-width:1100px; margin:0 auto; }
    h2 { text-align:center; color:#ff3b30; letter-spacing:1px; margin-bottom:18px; }
    #request-btn { display:none; background:linear-gradient(45deg,#ff3b30,#ff2d55); color:#fff; border:none; padding:12px 20px; border-radius:20px; font-weight:600; cursor:pointer; margin: 0 auto 16px; display:block; max-width:260px; }

    .gallery { display:grid; grid-template-columns:repeat(2,1fr); gap:10px; }
    .photo-card { position:relative; border-radius:12px; overflow:hidden; background:#111; aspect-ratio:3/4; box-shadow:0 2px 8px rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; }
    .photo-card .placeholder { width:100%; height:100%; display:flex; align-items:center; justify-content:center; gap:8px; flex-direction:column; color:#aaa; font-size:13px; padding:12px; text-align:center; }
    .photo-card.loading { background: linear-gradient(90deg,#111 0px,#222 40px,#111 80px); background-size:600px; animation:shimmer 1.5s infinite linear; }
    .photo-date { position:absolute; bottom:0; left:0; right:0; background:rgba(0,0,0,0.6); color:#ccc; font-size:10px; padding:6px; text-align:center; pointer-events:none; }

    .loader { text-align:center; color:var(--muted); margin-top:10px; display:none; }

    @keyframes shimmer { 0% { background-position:-200px 0 } 100% { background-position:200px 0 } }

    /* modal */
    .modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:999999; background:rgba(0,0,0,0.85); }
    .modal.open { display:flex; }
    .modal-content { position:relative; width:clamp(300px,90vw,1000px); max-height:90vh; border-radius:12px; overflow:hidden; background:#000; display:flex; align-items:center; justify-content:center; }
    .modal video { max-width:100%; max-height:100%; display:block; }
    .modal .close { position:absolute; top:10px; right:10px; background:rgba(0,0,0,0.5); color:#fff; border:none; font-size:20px; width:40px; height:40px; border-radius:999px; cursor:pointer; display:flex; align-items:center; justify-content:center; }
    /* play/pause toggle button */
    .modal .toggle {
      position:absolute;
      top:10px;
      right:60px;
      background:rgba(0,0,0,0.55);
      color:#fff;
      border:none;
      font-size:22px;
      width:40px;
      height:40px;
      border-radius:999px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
    }
    .modal .hint { position:absolute; bottom:8px; left:10px; right:10px; text-align:center; color:#ddd; font-size:13px; pointer-events:none; }

    .back-link { display:block; text-align:center; margin-top:18px; color:#007AFF; text-decoration:none; font-size:14px; }
    .spinner { width:36px; height:36px; border-radius:50%; border:4px solid rgba(255,255,255,0.08); border-top-color:#ff6b6b; animation:spin 1s linear infinite; }
    @keyframes spin { to { transform:rotate(360deg) } }

    .end-note { text-align:center; color:var(--muted); padding:12px 0; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>‚ù§Ô∏è Romantic Moments</h2>
    <button id="request-btn">üì∏ Request Instant Selfie</button>
    <div id="gallery" class="gallery" aria-live="polite"></div>
    <div id="main-loader" class="loader">Syncing memories... <span id="loader-spinner" style="display:inline-block;vertical-align:middle;margin-left:8px;"></span></div>
    <div id="end-note" class="end-note" style="display:none;">No more items.</div>
    <a href="index.html" class="back-link">‚Üê Back to Chat</a>
  </div>

  <!-- modal for playing one video -->
  <div id="modal" class="modal" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true">
      <button id="modal-close" class="close" title="Close">‚úï</button>
      <button id="modal-toggle" class="toggle" title="Play / Pause">‚ñ∂Ô∏è</button>
      <!-- video element inserted dynamically -->
      <div id="modal-spinner" style="position:absolute;display:none;"><div class="spinner"></div></div>
      <div class="hint">Tap video to pause/play ‚Ä¢ Tap outside or ‚úï to close</div>
    </div>
  </div>

  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
  import {
    getFirestore, collection, query, orderBy, limit, onSnapshot, getDocs, startAfter, serverTimestamp, addDoc
  } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";
  import { getAuth, setPersistence, browserLocalPersistence, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";

  // ============ CONFIG ============
  const firebaseConfig = {
    apiKey: "AIzaSyCuIDz0QP1Gpb6_40fz7xBY9xihPBuv3OE",
    authDomain: "sas-chat-61205.firebaseapp.com",
    projectId: "sas-chat-61205",
    storageBucket: "sas-chat-61205.firebasestorage.app",
    messagingSenderId: "775011152776",
    appId: "1:775011152776:web:e2bec0fe7e1fea99c5003d"
  };

  const ALLOWED_UIDS = [
    '3Och1e5kXyQfFsHtdGP6zosWMmr1',
    '9bX4Pye70VNymSt0CIZYBg7U47I3'
  ];

  // page settings
  const PAGE_SIZE = 20;

  // ============ INIT ============
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  const gallery = document.getElementById('gallery');
  const btn = document.getElementById('request-btn');
  const loader = document.getElementById('main-loader');
  const loaderSpinner = document.getElementById('loader-spinner');
  const endNote = document.getElementById('end-note');

  const modal = document.getElementById('modal');
  const modalContent = modal.querySelector('.modal-content');
  const modalClose = document.getElementById('modal-close');
  const modalToggle = document.getElementById('modal-toggle');
  const modalSpinner = document.getElementById('modal-spinner');

  // user-owned UI flag (not security)
  const vaultKey = localStorage.getItem("secure_vault");
  const currentUserLabel = localStorage.getItem("secure_user");

  // helpers
  function showMainLoader(show=true) { loader.style.display = show ? 'block' : 'none'; if (show) loaderSpinner.innerHTML = '<div class="spinner"></div>'; else loaderSpinner.innerHTML=''; }
  function decryptWithKey(cipherText) {
    try { return CryptoJS.AES.decrypt(cipherText, vaultKey).toString(CryptoJS.enc.Utf8); } catch (e) { return null; }
  }
  async function dataURItoBlob(dataURI) {
    // Using fetch gives browser chance to parse and avoids manual base64 decoding
    const res = await fetch(dataURI);
    return await res.blob();
  }

  // show request button UI flag (same as before)
  if (currentUserLabel === 'sam10') {
    btn.style.display = 'block';
    btn.addEventListener('click', requestSelfie);
  }

  // make auth persistence so index.html login survives across pages
  setPersistence(auth, browserLocalPersistence).catch(e => console.warn('Persistence err', e));

  // ============ PAGINATION STATE ============
  let lastDoc = null;           // for server-side pagination (startAfter)
  let loadingMore = false;
  let reachedEnd = false;
  let liveUnsubscribe = null;   // optional real-time on first page

  // active modal/video state
  let activeBlobUrl = null;
  let activeVideoEl = null;

  // modal controls
  modalClose.addEventListener('click', closeModal);
  modal.addEventListener('click', (ev) => {
    // clicking outside modal-content closes modal
    if (ev.target === modal) closeModal();
  });

  // Play/pause button handler
  modalToggle.addEventListener('click', (ev) => {
    ev.stopPropagation();
    if (!activeVideoEl) return;
    if (activeVideoEl.paused) {
      activeVideoEl.play().catch(()=>{});
    } else {
      activeVideoEl.pause();
    }
  });

  // Attach auth listener and gate the app
  onAuthStateChanged(auth, async (user) => {
    console.log('Auth changed ->', user ? user.uid : 'NOT SIGNED IN');
    if (!user) { window.location.href = 'index.html'; return; }
    if (!ALLOWED_UIDS.includes(user.uid)) { window.location.href = 'index.html'; return; }
    if (!vaultKey) { window.location.href = 'index.html'; return; }

    // initial page load (first page uses onSnapshot for realtime of first page)
    await loadFirstPage();
    // attach infinite scroll handler
    initScrollListener();
  });

  // ============ QUERY + LISTENERS ============

  async function loadFirstPage() {
    showMainLoader(true);
    // unsubscribe if exists
    if (liveUnsubscribe) { liveUnsubscribe(); liveUnsubscribe = null; }
    // query for latest PAGE_SIZE
    const q = query(collection(db, "cuteselfies"), orderBy("t", "desc"), limit(PAGE_SIZE));
    // Use onSnapshot for realtime updates *within* the first page
    liveUnsubscribe = onSnapshot(q, (snapshot) => {
      showMainLoader(false);
      if (snapshot.empty) {
        gallery.innerHTML = `<div style="grid-column:span 2;text-align:center;color:#444">No cute moments yet...</div>`;
        reachedEnd = true;
        endNote.style.display = 'block';
        return;
      }

      // Reset gallery and re-render current (keeps latest order)
      gallery.innerHTML = '';
      snapshot.docs.forEach((docSnap) => {
        const idx = snapshot.docs.indexOf(docSnap);
        renderPlaceholderCard(docSnap, idx);
      });

      // keep lastDoc for pagination (the last doc of this snapshot)
      lastDoc = snapshot.docs[snapshot.docs.length - 1];
      reachedEnd = snapshot.docs.length < PAGE_SIZE;
      endNote.style.display = reachedEnd ? 'block' : 'none';
    }, (err) => {
      console.error('snapshot error', err);
      showMainLoader(false);
      if (err && err.code === 'permission-denied') {
        alert('Permission denied ‚Äî auth failed or UID not allowed.');
        window.location.href = 'index.html';
      }
    });
  }

  async function loadNextPage() {
    if (loadingMore || reachedEnd || !lastDoc) return;
    loadingMore = true;
    showMainLoader(true);
    try {
      const qMore = query(collection(db, "cuteselfies"), orderBy("t", "desc"), startAfter(lastDoc), limit(PAGE_SIZE));
      const snap = await getDocs(qMore);
      if (snap.empty) {
        reachedEnd = true;
        endNote.style.display = 'block';
      } else {
        snap.docs.forEach((d, i) => {
          // Append placeholders for each new doc
          renderPlaceholderCard(d, gallery.children.length + i);
        });
        lastDoc = snap.docs[snap.docs.length - 1];
        reachedEnd = snap.docs.length < PAGE_SIZE;
        endNote.style.display = reachedEnd ? 'block' : 'none';
      }
    } catch (e) {
      console.error('loadNextPage err', e);
    } finally {
      loadingMore = false;
      showMainLoader(false);
    }
  }

  // Create a placeholder card (no content fetch/decrypt yet). On click -> fetch+decrypt and show modal.
  function renderPlaceholderCard(docSnap, index) {
    const id = docSnap.id;
    const data = docSnap.data();
    const dateText = data.t ? data.t.toDate().toLocaleDateString() + ' ' + data.t.toDate().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : 'Just now';

    // create card
    const card = document.createElement('div');
    card.className = 'photo-card';
    card.id = `card-${id}`;
    // show a small thumbnail-like placeholder; you can customize to show a stored 'thumb' field if you have one
    const placeholder = document.createElement('div');
    placeholder.className = 'placeholder';
    placeholder.innerHTML = `<div style="font-size:28px;">üé¨</div><div style="opacity:0.8">Tap to load</div><div style="font-size:12px;color:#777;margin-top:6px;">${dateText}</div>`;
    card.appendChild(placeholder);
    // date overlay (keeps parity with your previous UI)
    const dateEl = document.createElement('div');
    dateEl.className = 'photo-date';
    dateEl.textContent = dateText;
    card.appendChild(dateEl);

    // click handler: lazy load full data only when user requests
    card.addEventListener('click', (e) => {
      // avoid double clicks
      card.style.pointerEvents = 'none';
      openItemModal(docSnap).finally(() => {
        card.style.pointerEvents = '';
      });
    });

    // Insert at index (to preserve sort order)
    const children = gallery.children;
    if (index >= children.length) gallery.appendChild(card); else gallery.insertBefore(card, children[index]);
  }

  // ============ MODAL / LAZY LOAD ============
  async function openItemModal(docSnap) {
    // show spinner
    modalSpinner.style.display = 'block';
    modalSpinner.innerHTML = '<div class="spinner"></div>';
    modal.classList.add('open');
    modal.setAttribute('aria-hidden', 'false');

    // reset toggle while loading
    modalToggle.textContent = '‚ñ∂Ô∏è';

    try {
      // We expect docSnap.data().d to be encrypted URL (urlEnc)
      const data = docSnap.data();
      const urlEnc = data.d;
      // 1) decrypt urlEnc -> actual fetch URL for encrypted payload
      const fetchUrl = decryptWithKey(urlEnc);
      if (!fetchUrl) throw new Error('Failed to decrypt fetch URL');

      // 2) fetch encrypted payload (text) from your R2 / storage
      const resp = await fetch(fetchUrl);
      if (!resp.ok) throw new Error('Failed to fetch media');

      const encryptedText = await resp.text();

      // 3) decrypt encryptedText -> dataURI (base64)
      const dataUri = decryptWithKey(encryptedText);
      if (!dataUri) throw new Error('Failed to decrypt media content');

      // 4) convert to blob and create object URL
      const blob = await dataURItoBlob(dataUri);
      const blobUrl = URL.createObjectURL(blob);
      // cleanup previous blob if any
      if (activeBlobUrl) { try { URL.revokeObjectURL(activeBlobUrl); } catch(e){} }
      activeBlobUrl = blobUrl;

      // 5) create video element (autoplay triggered after metadata load). Attach click handler for pause/play
      const vid = document.createElement('video');
      vid.controls = true;
      vid.playsInline = true;
      vid.src = blobUrl;
      vid.style.maxWidth = '100%';
      vid.style.maxHeight = '100%';
      vid.preload = 'metadata'; // only metadata until play
      vid.setAttribute('tabindex', '0');

      // remove any previous video and attach
      const existing = modalContent.querySelector('video, img, .err-msg');
      if (existing) existing.remove();
      modalContent.appendChild(vid);
      activeVideoEl = vid;

      // When metadata is ready, autoplay (click to expand was user gesture so play should be allowed)
      vid.addEventListener('loadedmetadata', () => {
        vid.play().catch(()=>{});
      });

      // update toggle icon on play/pause events
      vid.addEventListener('play', () => { modalToggle.textContent = '‚è∏Ô∏è'; });
      vid.addEventListener('pause', () => { modalToggle.textContent = '‚ñ∂Ô∏è'; });

      // tap-to-toggle play/pause inside modal (as requested)
      vid.addEventListener('click', () => {
        if (vid.paused) vid.play().catch(()=>{}); else vid.pause();
      });

      // keyboard: space toggles
      vid.addEventListener('keydown', (ev) => {
        if (ev.code === 'Space') {
          ev.preventDefault();
          if (vid.paused) vid.play().catch(()=>{}); else vid.pause();
        }
      });

      // hide spinner once ready (or after short timeout)
      const hideSpinner = () => { modalSpinner.style.display = 'none'; };
      vid.addEventListener('canplay', hideSpinner);
      // fallback: if canplay doesn't fire, hide after 2s
      setTimeout(hideSpinner, 2000);

      // focus video for keyboard control
      setTimeout(()=>{ try { vid.focus(); } catch(e){} }, 150);
    } catch (err) {
      console.error('openItemModal err', err);
      modalSpinner.style.display = 'none';
      // show a small error message inside modal
      const errMsg = document.createElement('div');
      errMsg.className = 'err-msg';
      errMsg.style.padding = '18px';
      errMsg.style.color = '#f88';
      errMsg.textContent = 'Unable to load this item.';
      const existing = modalContent.querySelector('.err-msg');
      if (!existing) modalContent.appendChild(errMsg);
    }
  }

  function closeModal() {
    modal.classList.remove('open');
    modal.setAttribute('aria-hidden', 'true');
    // cleanup video and blob
    if (activeVideoEl) {
      try { activeVideoEl.pause(); } catch(e) {}
      activeVideoEl.remove();
      activeVideoEl = null;
    }
    if (activeBlobUrl) {
      try { URL.revokeObjectURL(activeBlobUrl); } catch(e) {}
      activeBlobUrl = null;
    }
    // reset toggle
    modalToggle.textContent = '‚ñ∂Ô∏è';
    // remove any error messages
    const errMsg = modalContent.querySelector('.err-msg');
    if (errMsg) errMsg.remove();
    modalSpinner.style.display = 'none';
  }

  // ============ INFINITE SCROLL (simple) ============
  function initScrollListener() {
    // Use scroll listener on window to detect near-bottom
    window.addEventListener('scroll', throttle(() => {
      if (loadingMore || reachedEnd) return;
      const scrolled = window.scrollY + window.innerHeight;
      const height = document.documentElement.scrollHeight;
      // when user is within 650px from bottom, load next page
      if (scrolled + 650 >= height) {
        loadNextPage();
      }
    }, 250));
  }

  function throttle(fn, wait) {
    let t = 0;
    return (...args) => {
      const now = Date.now();
      if (now - t > wait) {
        t = now;
        fn(...args);
      }
    };
  }

  // ============ Request Selfie (keeps previous logic) ============
  async function requestSelfie() {
    btn.innerText = "Requesting...";
    btn.disabled = true;
    try {
      await addDoc(collection(db, "quickselfierequest"), {
        requester: currentUserLabel || 'unknown',
        t: serverTimestamp()
      });
      alert("Request Sent! üì∏");
    } catch (e) {
      console.error('request selfie failed', e);
      alert('Request failed');
    } finally {
      btn.innerText = "üì∏ Request Instant Selfie";
      btn.disabled = false;
    }
  }

  // Helpful: clean up blobs if user navigates away while modal open
  window.addEventListener('beforeunload', () => {
    if (activeBlobUrl) try { URL.revokeObjectURL(activeBlobUrl); } catch(e) {}
  });
  </script>
</body>
</html>
